name: Full DevOps Pipeline (EKS)

on:
  push:
    branches:
      - main
      - master

env:
  # Docker image repo (Docker Hub)
  IMAGE_NAME: gokila2005/guvi-kec

  # EKS
  CLUSTER_NAME: chandru-eks
  REGION: ${{ secrets.AWS_REGION }}

  # Kubernetes
  NAMESPACE: myapp
  DEPLOYMENT_NAME: myapp

jobs:
  # ==========================================
  # STAGE 1 – VALIDATE (lightweight checks)
  # ==========================================
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate Docker build
        run: |
          docker build -t $IMAGE_NAME:ci .

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

      - name: Validate Kubernetes manifests (dry-run)
        run: |
          kubectl apply --dry-run=client -f k8s/namespace.yaml
          kubectl apply --dry-run=client -f k8s/deployment.yaml
          kubectl apply --dry-run=client -f k8s/service.yaml
          kubectl apply --dry-run=client -f k8s/ingress.yaml


  # ==========================================
  # STAGE 2 – BUILD & PUSH IMAGE
  # ==========================================
  build:
    runs-on: ubuntu-latest
    needs: validate

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:latest
          cache-to: type=inline


  # ==========================================
  # STAGE 3 – DEPLOY TO EKS (NO INFRA CHANGES)
  # ==========================================
  deploy:
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: AWS Login
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

      - name: Check if EKS cluster exists
        id: check_cluster
        run: |
          if aws eks describe-cluster --name $CLUSTER_NAME --region $REGION &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "✅ EKS cluster '$CLUSTER_NAME' exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "❌ EKS cluster '$CLUSTER_NAME' does not exist"
            echo "Create the cluster first using Terraform (eks-terraform/)"
            exit 1
          fi

      - name: Connect to EKS Cluster
        run: |
          aws eks update-kubeconfig --name $CLUSTER_NAME --region $REGION

      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Create namespace
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl get namespace $NAMESPACE

      - name: Deploy base manifests
        run: |
          kubectl apply -f k8s/deployment.yaml -n $NAMESPACE
          kubectl apply -f k8s/service.yaml -n $NAMESPACE

      - name: Update deployment with commit image and wait
        run: |
          kubectl set image deployment/$DEPLOYMENT_NAME \
            $DEPLOYMENT_NAME=$IMAGE_NAME:${{ github.sha }} \
            -n $NAMESPACE
          kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE --timeout=5m

      - name: Install/Verify Ingress Controller
        run: |
          if ! kubectl get namespace ingress-nginx &> /dev/null; then
            kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.5/deploy/static/provider/cloud/deploy.yaml
            kubectl wait --namespace ingress-nginx \
              --for=condition=ready pod \
              --selector=app.kubernetes.io/component=controller \
              --timeout=300s
          else
            echo "✅ Ingress controller already installed"
          fi

      - name: Deploy ingress
        run: |
          kubectl apply -f k8s/ingress.yaml -n $NAMESPACE

      - name: Get deployment status
        if: always()
        run: |
          kubectl get all -n $NAMESPACE
          kubectl get ingress -n $NAMESPACE -o wide || true
          kubectl get svc -n ingress-nginx || true
          kubectl logs -n $NAMESPACE -l app=$DEPLOYMENT_NAME --tail=50 || true

      - name: Show application endpoint
        run: |
          INGRESS_HOST=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          if [ -z "$INGRESS_HOST" ]; then
            INGRESS_HOST=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          fi

          if [ -n "$INGRESS_HOST" ] && [ "$INGRESS_HOST" != "pending" ]; then
            echo "✅ LoadBalancer URL: http://$INGRESS_HOST"
          else
            echo "⏳ LoadBalancer is still being provisioned..."
            echo "Run: kubectl get svc -n ingress-nginx ingress-nginx-controller"
          fi
